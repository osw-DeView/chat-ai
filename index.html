<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 기술 면접 시뮬레이터</title>
    <!-- React 및 Babel CDN -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- 스타일링 -->
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; background-color: #f4f7f9; margin: 0; padding: 20px; display: flex; justify-content: center; }
        #root { background-color: white; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); width: 100%; max-width: 800px; }
        .container { padding: 24px; }
        h1 { text-align: center; color: #333; }
        .chat-window { height: 400px; overflow-y: auto; border: 1px solid #e0e0e0; border-radius: 4px; padding: 16px; margin-bottom: 16px; display: flex; flex-direction: column; }
        .message { margin-bottom: 12px; display: flex; }
        .message.user { justify-content: flex-end; }
        .message.assistant { justify-content: flex-start; }
        .message .bubble { padding: 10px 15px; border-radius: 18px; max-width: 80%; line-height: 1.5; word-wrap: break-word; }
        .message.assistant .bubble { background-color: #f1f1f1; color: #333; }
        .message.user .bubble { background-color: #007bff; color: white; }
        .input-area { display: flex; gap: 10px; }
        textarea { flex-grow: 1; padding: 10px; border: 1px solid #ccc; border-radius: 4px; font-size: 1rem; resize: vertical; }
        button { padding: 10px 20px; border: none; border-radius: 4px; background-color: #007bff; color: white; font-size: 1rem; cursor: pointer; transition: background-color 0.2s; white-space: nowrap; }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #a0a0a0; cursor: not-allowed; }
        .start-container, .action-buttons { text-align: center; padding: 20px 0; }
        .turn-complete-notice { text-align: center; color: #007bff; font-weight: bold; margin-top: 10px; }
        .report-container { animation: fadeIn 0.5s; }
        .report-container h2 { border-bottom: 2px solid #eee; padding-bottom: 10px; }
        .report-container h3 { margin-top: 24px; color: #333; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        const App = () => {
            const [interviewState, setInterviewState] = useState('not_started');
            const [conversation, setConversation] = useState([]);
            const [currentUserInput, setCurrentUserInput] = useState('');
            const [isLoading, setIsLoading] = useState(false);
            const [evaluationReport, setEvaluationReport] = useState(null);
            const [isTurnLimitReached, setIsTurnLimitReached] = useState(false); // [추가] 턴 종료 상태

            const chatWindowRef = useRef(null);
            const API_BASE_URL = "http://127.0.0.1:8000";
            const SYSTEM_PROMPT = { role: "system", content: "당신은 최고의 IT 기술 면접 전문가입니다. ..." }; // 내용은 길어서 생략
            const MAX_TURNS = 3; // [추가] 최대 턴 수 정의

            useEffect(() => {
                if (chatWindowRef.current) {
                    chatWindowRef.current.scrollTop = chatWindowRef.current.scrollHeight;
                }
            }, [conversation]);

            const handleStartInterview = () => {
                const firstQuestion = { role: 'assistant', content: "안녕하세요! AI 기술 면접을 시작하겠습니다. 첫 번째 질문입니다: 프로세스와 스레드의 차이는 무엇인가요?" };
                setConversation([firstQuestion]);
                setInterviewState('in_progress');
                setIsTurnLimitReached(false);
            };

            const handleSendMessage = async () => {
                if (!currentUserInput.trim() || isLoading || isTurnLimitReached) return;

                const newUserMessage = { role: 'user', content: currentUserInput };
                const newConversation = [...conversation, newUserMessage];
                const userTurns = newConversation.filter(m => m.role === 'user').length;
                
                setConversation(newConversation);
                setCurrentUserInput('');

                // [수정됨] 턴 수에 따라 API 호출 로직 분기
                if (userTurns < MAX_TURNS) {
                    setIsLoading(true);
                    try {
                        const response = await fetch(`${API_BASE_URL}/interview/follow-up`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ messages: [SYSTEM_PROMPT, ...newConversation] })
                        });
                        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                        const data = await response.json();
                        
                        const assistantMessage = { role: 'assistant', content: data.response_text };
                        setConversation(prev => [...prev, assistantMessage]);
                    } catch (error) {
                        console.error("꼬리질문 요청 오류:", error);
                        const errorMessage = { role: 'assistant', content: "오류가 발생했습니다." };
                        setConversation(prev => [...prev, errorMessage]);
                    } finally {
                        setIsLoading(false);
                    }
                } else {
                    // 3턴이 완료된 경우
                    setIsTurnLimitReached(true);
                }
            };
            
            const handleEndInterview = async () => {
                if (isLoading) return;
                setIsLoading(true);
                try {
                    const response = await fetch(`${API_BASE_URL}/interview/evaluate`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ conversation: conversation })
                    });
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    const data = await response.json();

                    setEvaluationReport(data.evaluation_report);
                    setInterviewState('finished');
                } catch (error) {
                    console.error("최종 평가 요청 오류:", error);
                } finally {
                    setIsLoading(false);
                }
            };
            
            const handleRestart = () => {
                setInterviewState('not_started');
                setConversation([]);
                setEvaluationReport(null);
                setCurrentUserInput('');
                setIsTurnLimitReached(false); // [추가] 상태 초기화
            };

            const renderContent = () => {
                switch(interviewState) {
                    case 'in_progress':
                        return (
                            <div>
                                <div className="chat-window" ref={chatWindowRef}>
                                    {conversation.map((msg, index) => (
                                        <div key={index} className={`message ${msg.role}`}>
                                            <div className="bubble" dangerouslySetInnerHTML={{ __html: msg.content.replace(/\n/g, '<br />') }}></div>
                                        </div>
                                    ))}
                                    {isLoading && <div className="message assistant"><div className="bubble">AI가 답변을 생성 중입니다...</div></div>}
                                </div>
                                <div className="input-area">
                                    <textarea
                                        value={currentUserInput}
                                        onChange={(e) => setCurrentUserInput(e.target.value)}
                                        placeholder={isTurnLimitReached ? "3턴이 완료되었습니다. 평가를 진행해주세요." : "답변을 입력하세요..."}
                                        rows="3"
                                        disabled={isLoading || isTurnLimitReached} // [수정] 턴 종료 시 비활성화
                                        onKeyPress={(e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleSendMessage(); } }}
                                    />
                                    <button onClick={handleSendMessage} disabled={isLoading || isTurnLimitReached || !currentUserInput.trim()}>전송</button>
                                </div>
                                {/* [수정] 턴이 완료되면 안내 문구 표시 */}
                                {isTurnLimitReached && !isLoading && <p className="turn-complete-notice">모든 질문이 완료되었습니다. 아래 버튼을 눌러 최종 평가를 받아보세요.</p>}
                                <div className="action-buttons">
                                    <button onClick={handleEndInterview} disabled={isLoading}>면접 종료 및 평가받기</button>
                                </div>
                            </div>
                        );
                    case 'finished':
                        return evaluationReport && (
                            <div className="report-container">
                                <h2>최종 평가 보고서</h2>
                                <h3>종합 평가</h3>
                                <p><strong>종합 점수:</strong> {evaluationReport.overall_score}점</p>
                                <p>{evaluationReport.overall_feedback}</p>
                                <h3>개선 키워드</h3>
                                <ul>{evaluationReport.improvement_keywords.map((kw, i) => <li key={i}>{kw}</li>)}</ul>
                                <hr />
                                <h2>질문별 상세 평가</h2>
                                {evaluationReport.turn_evaluations.map(turn => (
                                    <div key={turn.turn}>
                                        <h3>턴 {turn.turn}: {turn.question}</h3>
                                        <p><strong>점수:</strong> {turn.score}점</p>
                                        <p>{turn.feedback}</p>
                                    </div>
                                ))}
                                <div className="action-buttons">
                                   <button onClick={handleRestart}>새 면접 시작하기</button>
                                </div>
                            </div>
                        );
                    default: // 'not_started'
                        return (
                            <div className="start-container">
                                <p style={{lineHeight: 1.6, color: '#555'}}>AI 면접관과 3턴의 기술 면접을 진행하고,<br/>면접이 끝난 후 상세한 평가 리포트를 받아보세요.</p>
                                <button onClick={handleStartInterview} disabled={isLoading}>
                                    {isLoading ? "준비 중..." : "면접 시작하기"}
                                </button>
                            </div>
                        );
                }
            };

            return (
                <div className="container">
                    <h1>AI 기술 면접 시뮬레이터</h1>
                    {renderContent()}
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>